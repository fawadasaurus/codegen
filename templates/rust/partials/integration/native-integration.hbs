/**********************************************
***** This file is generated, do not edit *****
***********************************************/

pub use vino_provider::prelude::*;

{{> component-imports . }}

#[derive(Debug)]
pub(crate) struct Dispatcher {}
#[async_trait]
impl Dispatch for Dispatcher {
  type Context = crate::Context;
  async fn dispatch(
    op: &str,
    context: Self::Context,
    data: TransportMap,
  ) -> Result<TransportStream, Box<NativeComponentError>>{
    let result = match op {
      {{#each interface.components}}
        "{{ name }}" => self::generated::{{snakeCase name}}::Component::default().execute(context, data).await,
      {{/each}}
      _ => Err(Box::new(NativeComponentError::new(format!(
        "Component not found on this provider: {}",
        op
      )))),
    }?;
    Ok(result)
  }
}

pub fn get_signature() -> ProviderSignature {
  let mut components = std::collections::HashMap::new();

  {{#each interface.components}}
    components.insert("{{name}}".to_owned(), {{#ifCond @root.type '!==' 'wellknown'}}generated{{else}}{{snakeCase @root.interface.name}}{{/ifCond}}::{{snakeCase name}}::signature());
  {{/each}}

  {{> provider-signature interface}}
}

{{> types interface }}

pub mod generated {
{{#each interface.components}}
  pub mod {{snakeCase name}} {
    {{#ifCond @root.type '===' 'wellknown'}}
    #![allow(unused)]
    use {{snakeCase @root.interface.name}}::{{snakeCase name}}::*;
    {{/ifCond}}
    use async_trait::async_trait;

    pub use vino_provider::prelude::*;

    pub fn signature() -> ComponentSignature {
      ComponentSignature {
        name: "{{name}}".to_owned(),
        inputs : inputs_list().into(),
        outputs : outputs_list().into(),
      }
    }

    #[derive(Default, Copy, Clone, Debug)]
    pub struct Component {}

    #[async_trait]
    impl NativeComponent for Component {
      type Context = crate::Context;
      async fn execute(
        &self,
        context: Self::Context,
        data: TransportMap,
      ) -> Result<TransportStream, Box<NativeComponentError>> {
        let inputs = populate_inputs(data).map_err(|e| NativeComponentError::new(e.to_string()))?;
        let (outputs, stream) = get_outputs();
        let result = tokio::spawn(crate::components::{{snakeCase name}}::job(inputs, outputs, context))
          .await
          .map_err(|e| {
            Box::new(NativeComponentError::new(format!(
              "Component error: {}",
              e
            )))
          })?;
        match result {
          Ok(_) => Ok(stream),
          Err(e) => Err(Box::new(NativeComponentError::new(e.to_string()))),
        }
      }
    }

    {{#ifCond @root.type '!==' 'wellknown'}}
      {{> native-inputs inputs }}
      {{> native-outputs outputs }}
    {{/ifCond}}

  }
{{/each}}
}

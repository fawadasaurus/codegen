
#[derive(Debug, Default)]
#[cfg(feature = "provider")]
pub struct OutputPorts {
  {{#each fields}}
    pub {{snakeCase name.value}}: {{pascalCase name.value}}PortSender,
  {{/each}}
}

#[must_use]
#[cfg(any(feature = "native", feature = "wasm"))]
pub fn outputs_list() -> HashMap<String, TypeSignature> {
  let mut map = HashMap::new();
  {{#each fields}}
    map.insert("{{name.value}}".to_owned(),{{> type-signature type}});
  {{/each}}
  map
}

{{#each fields}}
#[derive(Debug)]
#[cfg(feature = "provider")]
pub struct {{pascalCase name.value}}PortSender {
    port: PortChannel,
}

#[cfg(feature = "provider")]
impl Default for {{pascalCase name.value}}PortSender {
    fn default() -> Self {
        Self {
            port: PortChannel::new("{{name.value}}"),
        }
    }
}

#[cfg(feature = "provider")]
impl PortSender for {{pascalCase name.value}}PortSender {
    fn get_port(&self) -> Result<&PortChannel, ProviderError> {
      if self.port.is_closed() {
        Err(ProviderError::SendChannelClosed)
      } else {
        Ok(&self.port)
      }
    }

    fn get_port_name(&self) -> String {
      self.port.name.clone()
    }
}
{{/each}}

#[must_use]
#[cfg(feature = "provider")]
pub fn get_outputs() -> (OutputPorts, TransportStream) {
    let mut outputs = OutputPorts::default();
    let mut ports = vec![
    {{#each fields}}
    &mut outputs.{{snakeCase name.value}}.port,
    {{/each}}
    ];
    let stream = PortChannel::merge_all(&mut ports);
    (outputs, stream)
}


#[cfg(all(feature = "guest"))]
#[allow(missing_debug_implementations)]
pub struct Outputs {
  packets: ProviderOutput
}

#[cfg(all(feature = "native", feature = "guest"))]
impl Outputs {
  {{#each fields}}
    pub async fn {{snakeCase name.value}}(&mut self)-> Result<PortOutput<{{> expand-type type }}>, ProviderError> {
      let packets = self.packets.take("{{name.value}}").await;
      Ok(PortOutput::new("{{name.value}}".to_owned(), packets))
    }
  {{/each}}
}

#[cfg(all(feature = "wasm", feature = "guest"))]
impl Outputs {
  {{#each fields}}
    pub fn {{snakeCase name.value}}(&mut self)-> Result<PortOutput, WasmError> {
      let packets = self.packets.take("{{name.value}}").ok_or_else(|| WasmError::ResponseMissing("{{name.value}}".to_owned()))?;
      Ok(PortOutput::new("{{name.value}}".to_owned(), packets))
    }
  {{/each}}
}

#[cfg(all(feature = "wasm", feature = "guest"))]
impl From<ProviderOutput> for Outputs {
  fn from(packets: ProviderOutput) -> Self {
    Self{packets}
  }
}


#[cfg(all(feature = "native", feature = "guest"))]
impl From<BoxedTransportStream> for Outputs {
  fn from(stream: BoxedTransportStream) -> Self {
    Self{packets: ProviderOutput::new(stream)}
  }
}
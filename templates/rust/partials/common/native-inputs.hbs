
#[cfg(any(feature = "native", feature = "wasm"))]
pub fn populate_inputs(mut payload: TransportMap) -> Result<Inputs, TransportError> {
  Ok(Inputs {
    {{#each fields }}
    {{#ifCond type.name.value "==" "raw"}}
      {{snakeCase name.value}}: payload.consume_raw("{{name.value}}")?.into(),
    {{else}}
      {{snakeCase name.value}}: payload.consume("{{name.value}}")?,
    {{/ifCond}}
    {{/each}}
  })
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct Inputs {
{{#each fields }}
  #[serde(rename = "{{name.value}}")]
  pub {{snakeCase name.value}}: {{> expand-type type}},
{{/each}}
}

#[cfg(any(feature = "native", feature = "wasm"))]
impl From<Inputs> for TransportMap {
  fn from(inputs: Inputs) -> TransportMap {
    let mut map = TransportMap::new();
    {{#each fields }}
    {{#ifCond type.name.value "==" "raw"}}
      map.insert("{{snakeCase name.value}}".to_owned(), inputs.{{snakeCase name.value}}.into());
    {{else}}
      map.insert("{{snakeCase name.value}}".to_owned(), MessageTransport::success(&inputs.{{snakeCase name.value}}));
    {{/ifCond}}

    {{/each}}
    map
  }
}

#[must_use]
#[cfg(any(feature = "native", feature = "wasm"))]
pub fn inputs_list() -> HashMap<String, TypeSignature> {
  let mut map = HashMap::new();
  {{#each fields}}
    map.insert("{{name.value}}".to_owned(),{{> type-signature type}});
  {{/each}}
  map
}
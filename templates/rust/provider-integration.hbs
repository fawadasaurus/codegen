/**********************************************
***** This file is generated, do not edit *****
***********************************************/

use vino_provider::native::prelude::*;

use crate::generated;

#[derive(Debug)]
pub(crate) struct Dispatcher {}
#[async_trait]
impl Dispatch for Dispatcher {
  type Context = crate::Context;
  async fn dispatch(
    op: &str,
    context: Self::Context,
    data: TransportMap,
  ) -> Result<TransportStream, Box<NativeComponentError>>{
    use generated::*;
    let result = match op {
      {{#each schemas}}
        "{{document.namespace.name.value}}" => {{snakeCase file.unhyphenated}}::Component::default().execute(context, data).await,
      {{/each}}
      _ => Err(Box::new(NativeComponentError::new(format!(
        "Component not found on this provider: {}",
        op
      )))),
    }?;
    Ok(result)
  }
}

pub(crate) fn get_signature() -> ProviderSignature {
  use std::collections::HashMap;
  let mut components = HashMap::new();

  {{#each schemas}}
    components.insert("{{document.namespace.name.value}}".to_owned(), generated::{{snakeCase file.unhyphenated}}::signature());
  {{/each}}

  ProviderSignature {
    name: "".to_owned(),
    types: StructMap::todo(),
    components: components.into()
  }
}

{{#each schemas}}
pub (crate) mod {{snakeCase file.unhyphenated}} {
  #![allow(unused,unreachable_pub)]
  use std::collections::HashMap;

  use async_trait::async_trait;
  use serde::{
    Deserialize,
    Serialize,
  };

  #[cfg(feature = "native")]
  pub use vino_provider::native::prelude::*;

  #[cfg(feature = "wasm")]
  pub use vino_provider::wasm::prelude::*;

  pub(crate) fn signature() -> ComponentSignature {
    ComponentSignature {
      name: "{{document.namespace.name.value }}".to_owned(),
      inputs : inputs_list().into(),
      outputs : outputs_list().into(),
    }
  }

  {{#with document}}
  #[derive(Default)]
  pub(crate) struct Component {}

  #[async_trait]
  impl NativeComponent for Component {
    type Context = crate::Context;
    async fn execute(
      &self,
      context: Self::Context,
      data: TransportMap,
    ) -> Result<TransportStream, Box<NativeComponentError>> {
      let inputs = populate_inputs(data).map_err(|e| NativeComponentError::new(e.to_string()))?;
      let (outputs, stream) = get_outputs();
      let result = tokio::spawn(crate::components::{{snakeCase namespace.name.value}}::job(inputs, outputs, context))
        .await
        .map_err(|e| {
          Box::new(NativeComponentError::new(format!(
            "Component error: {}",
            e
          )))
        })?;
      match result {
        Ok(_) => Ok(stream),
        Err(e) => Err(Box::new(NativeComponentError::new(e.to_string()))),
      }
    }
  }

  {{#each definitions}}
  {{#switch kind}}
    {{#case "NamespaceDefinition"}}{{/case}}
    {{#case "TypeDefinition"}}
      {{#switch name.value}}
          {{> native-type-definition .}}
      {{/switch}}
    {{/case}}
    {{#default}}
      {{debug .}}
      {{panic "WIDL Node not yet handled"}}
    {{/default}}
  {{/switch}}
  {{/each}}
  {{/with}}
}
{{/each}}
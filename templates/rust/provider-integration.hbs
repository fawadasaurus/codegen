/**********************************************
***** This file is generated, do not edit *****
***********************************************/

use vino_provider::native::prelude::*;

use crate::generated;

#[derive(Debug)]
pub(crate) struct Dispatcher {}
#[async_trait]
impl Dispatch for Dispatcher {
  type Context = crate::Context;
  async fn dispatch(
    op: &str,
    context: Self::Context,
    data: TransportMap,
  ) -> Result<TransportStream, Box<NativeComponentError>>{
    use generated::*;
    let result = match op {
      {{#each schemas}}
        "{{document.namespace.name.value}}" => {{snakeCase file.unhyphenated}}::Component::default().execute(context, data).await,
      {{/each}}
      _ => Err(Box::new(NativeComponentError::new(format!(
        "Component not found on this provider: {}",
        op
      )))),
    }?;
    Ok(result)
  }
}

pub(crate) fn get_all_components() -> Vec<ComponentSignature> {
  vec![
  {{#each schemas}}
    generated::{{snakeCase file.unhyphenated}}::signature(),
  {{/each}}
  ]
}

{{#each schemas}}
pub (crate) mod {{snakeCase file.unhyphenated}} {
  #![allow(unused,unreachable_pub)]
  use std::collections::HashMap;

  use async_trait::async_trait;
  use serde::{
    Deserialize,
    Serialize,
  };

  pub(crate) use vino_provider::native::prelude::*;

  pub(crate) fn signature() -> ComponentSignature {
    ComponentSignature {
      name: "{{document.namespace.name.value }}".to_owned(),
      inputs : PortSignature::from_list(inputs_list()),
      outputs : PortSignature::from_list(outputs_list()),
    }
  }

  {{#with document}}
  #[derive(Default)]
  pub(crate) struct Component {}

  #[async_trait]
  impl NativeComponent for Component {
    type Context = crate::Context;
    async fn execute(
      &self,
      context: Self::Context,
      data: TransportMap,
    ) -> Result<TransportStream, Box<NativeComponentError>> {
      let inputs = populate_inputs(data).map_err(|e| NativeComponentError::new(format!("Input deserialization error: {}", e.to_string())))?;
      let (outputs, stream) = get_outputs();
      let result = crate::components::{{snakeCase namespace.name.value}}::job(inputs, outputs, context).await;
      match result {
        Ok(_) => Ok(stream),
        Err(e) => Err(Box::new(NativeComponentError::new(format!("Job failed: {}", e.to_string())))),
      }
    }
  }

  {{#each definitions}}
  {{#switch kind}}
    {{#case "NamespaceDefinition"}}{{/case}}
    {{#case "TypeDefinition"}}
      {{#switch name.value}}
          {{> native-type-definition .}}
      {{/switch}}
    {{/case}}
    {{#default}}
      {{debug .}}
      {{panic "WIDL Node not yet handled"}}
    {{/default}}
  {{/switch}}
  {{/each}}
  {{/with}}
}
{{/each}}